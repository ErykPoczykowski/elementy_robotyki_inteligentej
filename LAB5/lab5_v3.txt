
#include "NXT++.h"
#include <iostream>
#include <conio.h>
#include <ctime>
#include <vector>
using namespace std;
using namespace NXT;

Comm::NXTComm comm;

//PRZED UŻYCIEM SPRZETU DOKŁADNIE SPRAWDZAMY: 
//DO KTÓRYCH PORTÓW WEJŚCIOWYCH (IN) PODŁĄCZONE SĄ SENSORY,\
//DO KTÓRYCH PORTÓW WYJŚCIOWYCH (OUT) PODŁĄCZONE SĄ SERVO-MOTORY,
//STARAMY SIĘ PISAC KOD Z MOŻLIWOŚCIĄ ZATRZYMANIA ROBOTA W KAŻDEJ CHWILI,
//ROBOT POWIENIEN BYC PRZEMIESZCZONY W MIEJSCE TESTÓW ZA POŚREDNICTWEM ZDALNEGO STEROWANIA,
//CZUJNIKI SA INICJOWANE PRZED PETLA NIESKONCZONA,
//CZUJNIKI SA DEAKTYWOWANE ZA PETLA NIESKONCZONA, LUB PO KOMENDZIE k,

int convert(int k, int x)
{
	x = x - k;
	if (x > 88)
	{
		x = x - 176;
	}
	else if (x < -88)
	{
		x = 176 + x;
	}
	return x;
}

double ksi = 1, rho = 0.5;


int main()
{
	srand(time(NULL));

	cout << "Szukanie sygnalu... to moze zajac chwile.\n";
	if (NXT::OpenBT(&comm)) //initialize the NXT and continue if it succeeds
	{
		cout << "Sygnal znaleziony!";
		cout << "\nPoziom baterii = " << NXT::BatteryLevel(&comm);
		cout << "\nDostepna pamiec flash = " << NXT::GetAvailableFlash(&comm);

		int x = 30;//szybkość jazdy w przód i tył
		int xtemp = 30;//potrzebna do sprawdzania czy predkosc sie zmienila

		int y = 20;//szybkość obrotu w lewo, prawo
		int ytemp = 20;//potrzebna do sprawdzania czy predkosc sie zmienila

		char last_value;//zapamietana ostatnia instrukcja sterująca

		//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		//NXT::Sensor::SetTouch(&comm, IN_1);//inicjacja sensora dotyku

		//aktywacja kompasu,
		//NXT::Sensor::SetSonar(&comm, IN_3);

		//aktywacja czujnika koloru
		//NXT::Sensor::SetColor(&comm, IN_2, 'n');
		//int color;

		//aktywacja sonaru,
		//NXT::Sensor::SetSonar(&comm, IN_3);

		//początek programu
		NXT::StartProgram(&comm, "program1");

		//zmienna używana do sterowania
		char decyzja;

		cout << "\n ___Podstawowe sterowanie do uzupelnienia___";
		cout << "\n A - jazda w lewo";
		cout << "\n D - jazda w prawo";
		cout << "\n W - jazda na wprost";
		cout << "\n S - jazda do tylu";
		cout << "\n U - odczyt z sonaru";
		cout << "\n C - odczyt nasycenia koloru";
		cout << "\n V - odczyt z kompasu";
		cout << "\n H - Zatrzymanie silnikow";
		cout << "\n T - test";
		cout << "\n P - śledzenie piłki";
		cout << "\nK - Koniec Programu";

		do
		{
			//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
		/*
		if(NXT::Sensor::GetValue(&comm, IN_1)==1)
			{
			for(int i=1;i<1000;i=i+10)
				{
				NXT::PlayTone(&comm, i, 1);
				Wait(1);
				}
			}
		*/

			if (kbhit() == true)
			{

				decyzja = getch();

				if (decyzja == 'T' || decyzja == 't')
				{
					/*
					// ---------- Inicjalizacja kamery i tabeli danych ------------- //
					int il_ob;
					NXT::NxtCam::NxtCamInit(&comm, IN_1);
					NXT::NxtCam::NxtCamFlush(&comm, IN_1);
					il_ob = NXT::NxtCam::GetNxtCamNumObjects(&comm, IN_1);
					std::vector<std::vector <int>> data_cam;
					data_cam.resize(il_ob);
					for (int i = 0; i < data_cam.size(); i++)
					{
						data_cam[i].resize(6);
					}
					for (int i = 0; i < il_ob; i++)
					{
						for (int j = 0; j < 6; j++)
						{
							data_cam[i][j] = 0;
						}
					}
					// ------------------------------------------------------------- //

					int ilosc_c = 0;
					int ilosc_n = 0;
					// zakładamy niebieski = 1, czerwony = 2 dla symbolu koloru
					do
					{

						data_cam = NXT::NxtCam::GetNxtCamObjects(&comm, IN_1, 0); // pobranie informacji z kamery
						if (data_cam[0][0] == 1)
						{
							do
							{
								NXT::Motor::SetReverse(&comm, OUT_B, 10);
								NXT::Motor::SetReverse(&comm, OUT_C, 10);
							} while (data_cam[0][0] == 1);
						}
						if (data_cam[0][0] == 2)
						{
							ilosc_n += 1;
							do
							{
								NXT::Motor::SetForward(&comm, OUT_B, 10);
								NXT::Motor::SetForward(&comm, OUT_C, 10);
							} while (data_cam[0][0] == 2);

						}
						NXT::Motor::SetForward(&comm, OUT_B, 5);
						NXT::Motor::SetReverse(&comm, OUT_C, 5);

						cout << data_cam[0][0] << "\n";
					} while (data_cam[0][0] == 0);

					cout << "obiekt pierwszy: \n";
					cout << data_cam[0][0] << " symbol wykrytego koloru \n";
					cout << data_cam[0][1] << " wspolrzedna pikselowa x\n";
					cout << data_cam[0][2] << " wspolrzedna pikselowa y \n";
					cout << data_cam[0][3] << " wysokosc obiektu \n";
					cout << data_cam[0][4] << " szerokosc obiektu \n";
					NXT::Motor::Stop(&comm, OUT_B, 0);
					NXT::Motor::Stop(&comm, OUT_C, 0);
					*/

				}
				if (decyzja == 'P' || decyzja == 'p')
				{
					// ---------- Inicjalizacja kamery i tabeli danych ------------- //
					int il_ob;
					NXT::NxtCam::NxtCamInit(&comm, IN_1);
					NXT::NxtCam::NxtCamFlush(&comm, IN_1);
					il_ob = NXT::NxtCam::GetNxtCamNumObjects(&comm, IN_1);
					std::vector<std::vector <int>> data_cam;
					data_cam.resize(il_ob);
					for (int i = 0; i < data_cam.size(); i++)
					{
						data_cam[i].resize(6);
					}
					for (int i = 0; i < il_ob; i++)
					{
						for (int j = 0; j < 6; j++)
						{
							data_cam[i][j] = 0;
						}
					}
					// ------------------------------------------------------------- //
					// zakładamy niebieski = 1, czerwony = 2 dla symbolu koloru
					int k1, k2, k = 88, orient, cte, Pcte = 0, reakcja[2] = {};
					do
					{
						k1 = 10;
						k2 = 10;
						int kolor = 0;
						do
						{
							data_cam = NXT::NxtCam::GetNxtCamObjects(&comm, IN_1, 0);// informacje z kamery
							NXT::Motor::SetForward(&comm, OUT_B, 5);
							NXT::Motor::SetReverse(&comm, OUT_C, 5);

						} while (data_cam[0][0] == 0 && data_cam[1][0] == 0);

						if (max(data_cam[0][0], data_cam[1][0]) == 1)
						{
							kolor = 0; // niebieski
						}
						else
						{
							kolor = 1; // czerwony
						}

						if (reakcja[kolor] > 0)
						{
							NXT::Motor::SetForward(&comm, OUT_B, reakcja[kolor] * 5);
							NXT::Motor::SetForward(&comm, OUT_C, reakcja[kolor] * 5);
						}
						else if(reakcja[kolor] < 0)
						{
							NXT::Motor::SetReverse(&comm, OUT_B, reakcja[kolor] * 5);
							NXT::Motor::SetReverse(&comm, OUT_C, reakcja[kolor] * 5);
						}

						data_cam = NXT::NxtCam::GetNxtCamObjects(&comm, IN_1, 0);// informacje z kamery
						orient = data_cam[0][1];
						cte = convert(k, orient);
						int Dcte = cte - Pcte;
						double korekcja = ksi * cte + rho * Dcte;

						if (cte <= 0)
						{
							if (k1 + korekcja > k2)
							{
								NXT::Motor::SetForward(&comm, OUT_B, k2);
							}
							else if (k1 + korekcja < -k2)
							{
								NXT::Motor::SetReverse(&comm, OUT_B, k2);
							}
							else
							{
								NXT::Motor::SetForward(&comm, OUT_B, k1 + korekcja);
							}

						}

						if (cte > 0)
						{
							if (k2 - korekcja > k1)
							{
								NXT::Motor::SetForward(&comm, OUT_C, k1);
							}
							else if (k2 - korekcja < -k1)
							{
								NXT::Motor::SetReverse(&comm, OUT_C, k1);
							}
							else
							{
								NXT::Motor::SetForward(&comm, OUT_C, k2 - korekcja);
							}
						}
						Pcte = cte;

						if (kbhit() == true)
						{
							decyzja = getch();
							if (decyzja == 'K' || decyzja == 'k')
							{
								NXT::Motor::Stop(&comm, OUT_B, 0);
								NXT::Motor::Stop(&comm, OUT_C, 0);
								NXT::Motor::Stop(&comm, OUT_A, 0);
								NXT::Sensor::SetSonarOff(&comm, IN_1);
								//NXT::Sensor::SetColorOff(&comm, IN_2);

								break;
							}

							if (decyzja == 'Q' || decyzja == 'Q')
							{
								reakcja[kolor] += 1;
							}
							if (decyzja == 'E' || decyzja == 'E')
							{
								reakcja[kolor] -= 1;
							}
							continue;
						}

					} while (decyzja != 'K' && decyzja != 'k');

				}
				if (decyzja == 'N' || decyzja == 'n')
				{
					x -= 10;
				}

				if (decyzja == 'M' || decyzja == 'm')
				{
					x += 10;
				}

				if (decyzja == 'V' || decyzja == 'v')
				{
					y--;
				}

				if (decyzja == 'B' || decyzja == 'b')
				{
					y++;
				}
				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'A' || decyzja == 'a' || (ytemp != y && last_value == 'a'))
				{
					ytemp = y;
					last_value = 'a';
					NXT::Motor::SetForward(&comm, OUT_B, y);
					NXT::Motor::SetReverse(&comm, OUT_C, y);
					//cout<<"SonarValue = "<<NXT::Sensor::GetSonarValue(&comm, IN_4);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'D' || decyzja == 'd' || (ytemp != y && last_value == 'd'))
				{
					ytemp = y;
					last_value = 'd';
					NXT::Motor::SetReverse(&comm, OUT_B, y);
					NXT::Motor::SetForward(&comm, OUT_C, y);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'W' || decyzja == 'w' || (xtemp != x && last_value == 'w'))
				{
					xtemp = x;
					last_value = 'w';
					NXT::Motor::SetForward(&comm, OUT_B, x);
					NXT::Motor::SetForward(&comm, OUT_C, x);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'S' || decyzja == 's' || (xtemp != x && last_value == 's'))
				{
					xtemp = x;
					last_value = 's';
					NXT::Motor::SetReverse(&comm, OUT_B, x);
					NXT::Motor::SetReverse(&comm, OUT_C, x);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'H' || decyzja == 'h')
				{
					NXT::Motor::SetForward(&comm, OUT_B, 0);
					NXT::Motor::SetForward(&comm, OUT_C, 0);
					NXT::Motor::Stop(&comm, OUT_B, 0);
					NXT::Motor::Stop(&comm, OUT_C, 0);
				}

				//Przed uzyciem serwo sprawdzamy numer portu do którego jest podlączony,
				if (decyzja == 'K' || decyzja == 'k')
				{
					NXT::Motor::Stop(&comm, OUT_B, 0);
					NXT::Motor::Stop(&comm, OUT_C, 0);
					NXT::Motor::Stop(&comm, OUT_A, 0);
					NXT::Sensor::SetSonarOff(&comm, IN_1);
					NXT::Sensor::SetColorOff(&comm, IN_2);

					break;
				}

				//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
				//if (decyzja == 'U' || decyzja == 'u')
				//{
				//	cout << "\n Wskazanie sonaru = " << NXT::Sensor::GetSonarValue(&comm, IN_3);
				//}
				if (decyzja == 'V' || decyzja == 'v')
				{
					cout << "\n Wskazanie kompasu = " << NXT::Sensor::GetSonarValue(&comm, IN_3);
				}

				//Przed uzyciem sprawdzamy numer portu do którego jest podlączony sensor, 
				//if (decyzja == 'C' || decyzja == 'c')
				//{
				//	color = NXT::Sensor::GetValue(&comm, IN_2);
				//	Wait(50);
				//	cout << "\nNasycenie swaitla = " << color;
				//}

				continue;
			}
		} while (decyzja != 'k' && decyzja != 'K');

		NXT::StopProgram(&comm);

	}
	NXT::Close(&comm); //close communication with NXT

	cout << "\n\nPress ENTER to close program";
	getchar();

	return 0;
}


//opcje dotyczace Mindstorm NXT v. 1.0

//if(decyzja=='L' || decyzja=='l')
// {
//  NXT::Sensor::SetLight(&comm, IN_3, 1);
//  Wait(50);
//  cout<<"LightValue = "<<NXT::Sensor::GetValue(&comm, IN_3);
//  Wait(50);
//  NXT::Sensor::SetLight(&comm, IN_3, 0);
// }

	//if(decyzja=='O' || decyzja=='o')
// {
// NXT::Sensor::SetSound(&comm, IN_2);
// Wait(50);
// cout<<"SoundValue = "<<NXT::Sensor::GetValue(&comm, IN_2);
// }

